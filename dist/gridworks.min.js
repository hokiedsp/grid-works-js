/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(1);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Javascript function to enable user interaction on CSS-Grid
// - enable/disable mouse interaction to resize
// - remember default size
// - programatically adjust size
// - reset to default
//
// - grid layout may change depending on its brwoser window size

// action commands:
//    enable      -
//    disable     -
//    freeze
//    melt
//    hide        -
//    show        -
//    reconfigure -
//    restore     -
//    save        -
//    load

var gridWorks = function () {
  _createClass(gridWorks, [{
    key: "enabled",
    get: function get() {
      return this._enabled;
    },
    set: function set(value) {
      if (value) this.enable();else this.disable();
    }
    // get colHidden() {
    //   return this._colHidden;
    // }
    // set colHidden(values) {
    //   values = [...values].map(value => Boolean(value));
    //   this._colHidden = gridWorks._pad(values, this._colWidths.length, false);
    // }
    // get rowHidden() {
    //   return this._colMinWidths;
    // }
    // set rowHidden(values) {
    //   values = [...values].map(value => Boolean(value));
    //   this._rowHidden = gridWorks._pad(values, this._rowHeights.length, false);
    // }

  }, {
    key: "colLineFixed",
    get: function get() {
      return this._colLineFixed;
    },
    set: function set(values) {
      values = [].concat(_toConsumableArray(values)).map(function (value) {
        return Boolean(value);
      });
      this._colLineFixed = gridWorks._pad(values, this._colLinePositions.length, false);
    }
  }, {
    key: "rowLineFixed",
    get: function get() {
      return this._rowLineFixed;
    },
    set: function set(values) {
      values = [].concat(_toConsumableArray(values)).map(function (value) {
        return Boolean(value);
      });
      this._rowLineFixed = gridWorks._pad(values, this._rowLinePositions.length, false);
    }
  }, {
    key: "colMinWidths",
    get: function get() {
      return this._colMinWidths;
    },
    set: function set(values) {
      values = [].concat(_toConsumableArray(values)).map(function (value) {
        return isFinite(value) && value > 0 ? value : 1;
      });
      this._colMinWidths = gridWorks._pad(values, this._colWidths.length, values[values.length - 1]);
    }
  }, {
    key: "colMaxWidths",
    get: function get() {
      return this._colMaxWidths;
    },
    set: function set(values) {
      values = [].concat(_toConsumableArray(values)).map(function (value) {
        return value > 0 ? value : Infinity;
      });
      this._colMaxWidths = gridWorks._pad(values, this._colWidths.length, values[values.length - 1]);
    }
  }, {
    key: "rowMinHeights",
    get: function get() {
      return this._rowMinHeights;
    },
    set: function set(values) {
      values = [].concat(_toConsumableArray(values)).map(function (value) {
        return isFinite(value) && value > 0 ? value : 1;
      });
      this._rowMinHeights = gridWorks._pad(values, this._rowHeights.length, values[values.length - 1]);
    }
  }, {
    key: "rowMaxHeights",
    get: function get() {
      return this._rowMaxHeights;
    },
    set: function set(values) {
      values = [].concat(_toConsumableArray(values)).map(function (value) {
        return value > 0 ? value : Infinity;
      });
      this._rowMaxHeights = gridWorks._pad(values, this._rowHeights.length, values[values.length - 1]);
    }
  }], [{
    key: "_pad",
    value: function _pad(values, len) {
      var last_value = values[values.length - 1];
      while (values.length < len) {
        values.push(last_value);
      }return values;
    }
  }]);

  function gridWorks(eGrid, opts) {
    var _this = this;

    _classCallCheck(this, gridWorks);

    // options
    this._enabled = true;
    this._colLineFixed = [false]; // element true to make the column edge unadjustable, default: false
    this._rowLineFixed = [false]; // element true make the row edge unadjustable, default: false
    // this._colHidden = [false]; // element true to make the column edge unadjustable, default: false
    // this._rowHidden = [false]; // element true make the row edge unadjustable, default: false

    this._colMinWidths = [1]; // element sets minimum column width in pixels
    this._colMaxWidths = [Infinity]; // element sets maximum column width in pixels
    this._rowMinHeights = [1]; // element sets minimum row height in pixels
    this._rowMaxHeights = [Infinity]; // element sets maximum row height in pixels

    this._eGrid = eGrid;
    this._colLineNames = [];
    this._colWidths = [];
    this._colLinePositions = [];
    this._rowLineNames = [];
    this._rowHeights = [];
    this._rowLinePositions = [];
    this._gridCells = [];
    this._state = 0; // 0:idle|1:adjust
    this._currentCell;
    this._activeColLine = -1;
    this._activeRowLine = -1;
    this._offsetX0;
    this._offsetY0;

    if (["grid", "inline-grid"].every(function (value) {
      return value !== window.getComputedStyle(_this._eGrid).display;
    })) throw "Container is not a grid";

    this._analyze(); // get grid lines and layout of its items
    this._configure(); // set callbacks on its items

    // create object-bound callback functions
    this._mouseover = this.onMouseOverBorder.bind(this);
    this._mouseout = this.onMouseOutBorder.bind(this);
    this._mousedown = this.onMouseDownBorder.bind(this);
    this._onmousemove = this.onMouseMove.bind(this);
    this._onmouseup = this.onMouseUp.bind(this);
  }

  _createClass(gridWorks, [{
    key: "enable",
    value: function enable() {
      var _this2 = this;

      if (this._enabled) return; // nothing to do
      this._enabled = true;
      this._gridCells.forEach(function (cell) {
        // add mouse event listeners
        cell.eBorder.addEventListener("mouseover", _this2._mouseover);
        cell.eBorder.addEventListener("mouseout", _this2._mouseout);
        cell.eBorder.addEventListener("mousedown", _this2._mousedown);
      });
    }
  }, {
    key: "disable",
    value: function disable() {
      var _this3 = this;

      if (!this._enabled) return; // nothing to do
      this._enabled = false;
      this._gridCells.forEach(function (cell) {
        // add mouse event listeners
        cell.eBorder.removeEventListener("mouseover", _this3._mouseover);
        cell.eBorder.removeEventListener("mouseout", _this3._mouseout);
        cell.eBorder.removeEventListener("mousedown", _this3._mousedown);
      });
    }
    // hide() {}
    // show() {}
    // reconfigure() {}
    // restore() {}
    // save() {}
    // load() {}

    /**
     * Analyzes the grid container's attributes and populates the following "private" properties:
        _colLineNames
        _colWidths
        _colLinePositions
        _rowLineNames
        _rowHeights
        _rowLinePositions
        _gridCells
     */

  }, {
    key: "_analyze",
    value: function _analyze() {
      var _this4 = this;

      // "##px" -> ## converter
      var cssPxSize = function cssPxSize(str) {
        return Number(str.match(/\d+(?=px)/));
      };

      // identify the (relative) position of the grid lines
      var parseTemplateDefs = function parseTemplateDefs(cssParams, offset) {
        var wasSize = cssParams.template[0] != "[";
        var sizes = [],
            names = wasSize ? [[]] : [];
        cssParams.template.match(/(\[[^\]]+\])|([\d\.]+)/g).forEach(function (token) {
          if (token[0] == "[") {
            // edge names
            // names.push(token.slice(1, -1).match(/[^ ]+/g));
            names.push(token);
            wasSize = false;
          } else {
            sizes.push(Number(token));
            if (wasSize) names.push(""); //names.push([]); // no name given
            wasSize = true;
          }
        });

        // calculate the line positions
        var edges = sizes.reduce(function (r, a, i) {
          return r.push(r[i] + a), r;
        }, [offset + cssPxSize(cssParams.border) + cssPxSize(cssParams.padding)]);
        if (cssParams.gap && cssParams.gap != "normal") {
          var gap = cssPxSize(cssParams.gap);
          edges = edges.map(function (pos) {
            return pos + i * gap;
          });
        }

        // template, gap, border, padding
        return {
          names: names,
          sizes: sizes,
          edges: edges
        };
      };

      // getBoundingClientRect() returns the position of outside edges of borders
      var gridPos = function (_ref) {
        var top = _ref.top,
            left = _ref.left;
        return { top: top, left: left };
      }(this._eGrid.getBoundingClientRect());

      // analyze the column configurations

      // analyze the row configurations
      var _parseTemplateDefs = parseTemplateDefs(function (_ref2) {
        var gridTemplateColumns = _ref2.gridTemplateColumns,
            columnGap = _ref2.columnGap,
            borderLeftWidth = _ref2.borderLeftWidth,
            paddingLeft = _ref2.paddingLeft;
        return {
          template: gridTemplateColumns,
          gap: columnGap,
          border: borderLeftWidth,
          padding: paddingLeft
        };
      }(window.getComputedStyle(this._eGrid)), gridPos.left);

      this._colLineNames = _parseTemplateDefs.names;
      this._colWidths = _parseTemplateDefs.sizes;
      this._colLinePositions = _parseTemplateDefs.edges;

      // collect grid cells' CSS's
      var _parseTemplateDefs2 = parseTemplateDefs(function (_ref3) {
        var gridTemplateRows = _ref3.gridTemplateRows,
            rowGap = _ref3.rowGap,
            borderTopWidth = _ref3.borderTopWidth,
            paddingTop = _ref3.paddingTop;
        return {
          template: gridTemplateRows,
          gap: rowGap,
          border: borderTopWidth,
          padding: paddingTop
        };
      }(window.getComputedStyle(this._eGrid)), gridPos.top);

      this._rowLineNames = _parseTemplateDefs2.names;
      this._rowHeights = _parseTemplateDefs2.sizes;
      this._rowLinePositions = _parseTemplateDefs2.edges;
      this._gridCells = [].concat(_toConsumableArray(this._eGrid.children)).reduce(function (r, cell, i) {
        var css = window.getComputedStyle(cell);
        var cellRect = cell.getBoundingClientRect();
        var findLine = function findLine(px, lines) {
          return lines.map(function (line) {
            return Math.abs(line - px);
          }).reduce(function (iMin, x, i, arr) {
            return x < arr[iMin] ? i : iMin;
          }, 0);
        };
        return r.push({
          eBorder: cell,
          eCellCSS: css,
          left: findLine(cellRect.left - cssPxSize(css.marginLeft), _this4._colLinePositions),
          right: findLine(cellRect.left + cellRect.width + cssPxSize(css.marginRight), _this4._colLinePositions),
          top: findLine(cellRect.top - cssPxSize(css.marginTop), _this4._rowLinePositions),
          bottom: findLine(cellRect.top + cellRect.height + cssPxSize(css.marginBottom), _this4._rowLinePositions)
        }), r;
      }, []);
    }

    /**
     *
     */

  }, {
    key: "_configure",
    value: function _configure() {
      this._eGrid.classList.add("grid-works", "wrapper");
      this._gridCells.forEach(function (cell) {
        var _eContent$classList;

        // insert a borderless div between the grid cell and its content
        var cssBorder = window.getComputedStyle(cell.eBorder);
        var innerHTML = cell.eBorder.innerHTML;

        //
        var eContent = document.createElement("div");
        eContent.className = "grid-works content";
        (_eContent$classList = eContent.classList).add.apply(_eContent$classList, _toConsumableArray(cell.eBorder.classList));
        eContent.innerHTML = innerHTML;

        eContent.style = "height: 100%; width: 100%; margin: 0; border: none; padding: 0";
        eContent.style.paddingLeft = cssBorder.paddingLeft;
        eContent.style.paddingTop = cssBorder.paddingTop;
        eContent.style.paddingRight = cssBorder.paddingRight;
        eContent.style.paddingBottom = cssBorder.paddingBottom;
        cell.eContent = eContent;

        cell.eBorder.classList.add("grid-works", "border");
        cell.eBorder.innerHTML = "";
        cell.eBorder.appendChild(eContent);
        cell.eBorder.style.padding = "0";

        cell.eContent.addEventListener("mouseover", function (e) {
          // stop eContent's mouseover to bubble to eBorder
          e.stopPropagation();
        });
        cell.eContent.addEventListener("mouseout", function (e) {
          // stop eContent's mouseout to bubble to eBorder
          e.stopPropagation();
        });
      });

      // set configurations
      // this.colHidden = this._colHidden;
      // this.rowHidden = this._rowHidden;
      this.colLineFixed = this._colLineFixed;
      this.rowLineFixed = this._rowLineFixed;
      this.colMinWidths = this._colMinWidths;
      this.colMaxWidths = this._colMaxWidths;
      this.rowMinHeights = this._rowMinHeights;
      this.rowMaxHeights = this._rowMaxHeights;
    }
  }, {
    key: "_is_adjustable",
    value: function _is_adjustable(line, edge, fixed_edges) {
      console.log(!(fixed_edges[line] || line == edge));
      return !(fixed_edges[line] || line == edge);
    }
  }, {
    key: "_on_border",
    value: function _on_border(e) {
      // initialize return object
      var rval = { left: false, right: false, top: false, bottom: false };

      // get current cell, exit if not on border
      this._currentCell = this._gridCells.find(function (cell) {
        return e.target == cell.eBorder;
      });
      if (!this._currentCell) return rval;

      // detect if mouse is on which border
      var left_offset = e.clientX - e.target.offsetLeft;
      var right_offset = e.target.offsetLeft + e.target.offsetWidth - e.clientX - 1;
      var top_offset = e.clientY - e.target.offsetTop;
      var bottom_offset = e.target.offsetTop + e.target.offsetHeight - e.clientY - 1;

      var left_thickness = getComputedStyle(e.target).borderLeftWidth.slice(0, -2);
      var right_thickness = getComputedStyle(e.target).borderRightWidth.slice(0, -2);
      var top_thickness = getComputedStyle(e.target).borderTopWidth.slice(0, -2);
      var bottom_thickness = getComputedStyle(e.target).borderBottomWidth.slice(0, -2);

      // then check if the lines are adjustable
      if (left_offset <= left_thickness) {
        rval.left = this._is_adjustable(this._currentCell.left, 0, this._colLineFixed);
      } else if (right_offset <= right_thickness) {
        rval.right = this._is_adjustable(this._currentCell.right, this._colLinePositions.length - 1, this._colLineFixed);
      }

      if (top_offset <= top_thickness) {
        rval.top = this._is_adjustable(this._currentCell.top, 0, this._rowLineFixed);
      } else if (bottom_offset <= bottom_thickness) {
        rval.bottom = this._is_adjustable(this._currentCell.bottom, this._rowLinePositions.length - 1, this._rowLineFixed);
      }
      return rval;
    }
  }, {
    key: "onMouseOverBorder",
    value: function onMouseOverBorder(e) {
      if (this._state > 0) return;

      // detect what could be adjusted: col/row/both
      var on = this._on_border(e);

      // set eBorder class
      if (on.left || on.right) e.target.classList.add("col");
      if (on.top || on.bottom) e.target.classList.add("row");
    }
  }, {
    key: "onMouseMoveBorder",
    value: function onMouseMoveBorder(e) {
      if (this._state > 0) return;

      // detect what could be adjusted: col/row/both
      var on = this._on_border(e);

      // update eBorder class
      if (on.left || on.right) e.target.classList.add("col");else e.target.classList.remove("col");
      if (on.top || on.bottom) e.target.classList.add("row");else e.target.classList.remove("row");
    }
  }, {
    key: "onMouseOutBorder",
    value: function onMouseOutBorder(e) {
      if (this._state > 0) return;

      // turn off cursor only if not active
      if (!this._state) e.target.classList.remove("col", "row");
    }
  }, {
    key: "onMouseDownBorder",
    value: function onMouseDownBorder(e) {
      // id which border(s) is hit
      var on = this._on_border(e);
      if (on.left) this._activeColLine = this._currentCell.left;else if (on.right) this._activeColLine = this._currentCell.right;
      if (on.top) this._activeRowLine = this._currentCell.top;else if (on.bottom) this._activeRowLine = this._currentCell.bottom;

      // check for "erroneous" callback
      if (this._activeColLine < 0 && this._activeRowLine < 0) return 0;

      // turn on grid-adjuster
      this._state = 1;

      // store the current mouse pointer location
      if (this._activeColLine >= 0) this._offsetX0 = this._colLinePositions[this._activeColLine] - e.pageX;
      if (this._activeRowLine >= 0) this._offsetY0 = this._rowLinePositions[this._activeRowLine] - e.pageY;

      // add window mousemove callback
      window.addEventListener("mousemove", this._onmousemove);
      window.addEventListener("mouseup", this._onmouseup);
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp(e) {
      // remove the mousemove callback
      window.removeEventListener("mousemove", this._onmousemove);
      window.removeEventListener("mouseup", this._onmouseup);

      // turn off grid-adjuster
      this._state = 0;

      // clear active line indicators
      this._activeColLine = -1;
      this._activeRowLine = -1;
    }
  }, {
    key: "_update_template",
    value: function _update_template(line, newpos, cssName, names, sizes, edges, mins, maxs) {
      // get the change
      var delta = newpos - edges[line];
      var newSize0 = sizes[line - 1] + delta;
      var newSize1 = sizes[line] - delta;
      if (newSize0 < mins[line - 1]) {
        newSize1 = newSize0 + newSize1 - mins[line - 1];
        newSize0 = mins[line - 1];
      } else if (newSize1 < mins[line]) {
        newSize0 = newSize1 + newSize0 - mins[line];
        newSize1 = mins[line];
      } else if (newSize0 > maxs[line - 1]) {
        newSize1 = newSize0 + newSize1 - maxs[line - 1];
        newSize0 = maxs[line - 1];
      } else if (newSize1 > maxs[line]) {
        newSize0 = newSize1 + newSize0 - maxs[line];
        newSize1 = maxs[line];
      }

      // update the edge position and sizes of adjacent cells
      edges[line] = edges[line - 1] + newSize0;
      sizes[line - 1] = newSize0;
      sizes[line] = newSize1;

      // update the template
      this._eGrid.style[cssName] = sizes.reduce(function (cssstr, size, i) {
        cssstr += size + "px" + names[i + 1];
        return cssstr;
      }, names[0]);

      // return updated edges & sizes
      return {
        sizes: sizes,
        edges: edges
      };
    }
  }, {
    key: "onMouseMove",
    value: function onMouseMove(e) {
      e.preventDefault();
      if (this._activeColLine >= 0) {
        ;

        var _update_template2 = this._update_template(this._activeColLine, this._offsetX0 + e.pageX, "gridTemplateColumns", this._colLineNames, this._colWidths, this._colLinePositions, this._colMinWidths, this._colMaxWidths);

        this._colWidths = _update_template2.sizes;
        this._colLinePositions = _update_template2.edges;
      }if (this._activeRowLine >= 0) {
        ;

        var _update_template3 = this._update_template(this._activeRowLine, this._offsetY0 + e.pageY, "gridTemplateRows", this._rowLineNames, this._rowHeights, this._rowLinePositions, this._rowMinHeights, this._rowMaxHeights);

        this._rowHeights = _update_template3.sizes;
        this._rowLinePositions = _update_template3.edges;
      }
    }
  }, {
    key: "setOptions",
    value: function setOptions(opts) {
      if (opts._colLineFixed) {
        // options
        this._colLineFixed = []; // element true to make the column edge unadjustable, default: false
      }
      this._colMinWidths = []; // element sets minimum column width in pixels
      this._colMaxWidths = []; // element sets maximum column width in pixels
      this._rowLineFixed = []; // element true make the row edge unadjustable, default: false
      this._rowMinHeights = []; // element sets minimum row height in pixels
      this._rowMaxHeights = []; // element sets maximum row height in pixels
    }
  }]);

  return gridWorks;
}();

// make gridWorks available to all Objects


Object.defineProperty(Element.prototype, "gridWorks", {
  get: function get() {
    Object.defineProperty(this, "gridWorks", {
      value: new gridWorks(this, [].concat(Array.prototype.slice.call(arguments)))
    });

    return this.gridWorks;
  },
  configurable: true,
  writeable: false
});

/***/ }),
/* 1 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ })
/******/ ]);