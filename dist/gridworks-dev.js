/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\n// Javascript function to enable user interaction on CSS-Grid\r\n// - enable/disable mouse interaction to resize\r\n// - remember default size\r\n// - programatically adjust size\r\n// - reset to default\r\n//\r\n// - grid layout may change depending on its brwoser window size\r\n\r\n// action commands:\r\n//    enable      -\r\n//    disable     -\r\n//    freeze\r\n//    melt\r\n//    hide        -\r\n//    show        -\r\n//    reconfigure -\r\n//    restore     -\r\n//    save        -\r\n//    load\r\n\r\nclass gridWorks {\r\n  static _pad(values, len) {\r\n    let last_value = values[values.length - 1];\r\n    while (values.length < len) values.push(last_value);\r\n    return values;\r\n  }\r\n  get enabled() {\r\n    return this._enabled;\r\n  }\r\n  set enabled(value) {\r\n    if (value) this.enable();\r\n    else this.disable();\r\n  }\r\n  // get colHidden() {\r\n  //   return this._colHidden;\r\n  // }\r\n  // set colHidden(values) {\r\n  //   values = [...values].map(value => Boolean(value));\r\n  //   this._colHidden = gridWorks._pad(values, this._colWidths.length, false);\r\n  // }\r\n  // get rowHidden() {\r\n  //   return this._colMinWidths;\r\n  // }\r\n  // set rowHidden(values) {\r\n  //   values = [...values].map(value => Boolean(value));\r\n  //   this._rowHidden = gridWorks._pad(values, this._rowHeights.length, false);\r\n  // }\r\n  get colLineFixed() {\r\n    return this._colLineFixed;\r\n  }\r\n  set colLineFixed(values) {\r\n    values = [...values].map(value => Boolean(value));\r\n    this._colLineFixed = gridWorks._pad(\r\n      values,\r\n      this._colLinePositions.length,\r\n      false\r\n    );\r\n  }\r\n  get rowLineFixed() {\r\n    return this._rowLineFixed;\r\n  }\r\n  set rowLineFixed(newName) {\r\n    values = [...values].map(value => Boolean(value));\r\n    this._rowLineFixed = gridWorks._pad(\r\n      values,\r\n      this._rowLinePositions.length,\r\n      false\r\n    );\r\n  }\r\n  get colMinWidths() {\r\n    return this._colMinWidths;\r\n  }\r\n  set colMinWidths(values) {\r\n    values = [...values].map(\r\n      value => (isFinite(value) && value > 0 ? value : 1)\r\n    );\r\n    this._colMinWidths = gridWorks._pad(\r\n      values,\r\n      this._colWidths.length,\r\n      values[values.length - 1]\r\n    );\r\n  }\r\n  get colMaxWidths() {\r\n    return this._colMaxWidths;\r\n  }\r\n  set colMaxWidths(values) {\r\n    values = [...values].map(value => (value > 0 ? value : Infinity));\r\n    this._colMaxWidths = gridWorks._pad(\r\n      values,\r\n      this._colWidths.length,\r\n      values[values.length - 1]\r\n    );\r\n  }\r\n  get rowMinHeights() {\r\n    return this._rowMinHeights;\r\n  }\r\n  set rowMinHeights(newName) {\r\n    values = [...values].map(\r\n      value => (isFinite(value) && value > 0 ? value : 1)\r\n    );\r\n    this._rowMinHeights = gridWorks._pad(\r\n      values,\r\n      this._rowHeights.length,\r\n      values[values.length - 1]\r\n    );\r\n  }\r\n  get rowMaxHeights() {\r\n    return this._rowMaxHeights;\r\n  }\r\n  set rowMaxHeights(newName) {\r\n    values = [...values].map(value => (value > 0 ? value : Infinity));\r\n    this._rowMaxHeights = gridWorks._pad(\r\n      values,\r\n      this._rowHeights.length,\r\n      values[values.length - 1]\r\n    );\r\n  }\r\n\r\n  constructor(eGrid, opts) {\r\n    // options\r\n    this._enabled = true;\r\n    this._colLineFixed = [false]; // element true to make the column edge unadjustable, default: false\r\n    this._rowLineFixed = [false]; // element true make the row edge unadjustable, default: false\r\n    // this._colHidden = [false]; // element true to make the column edge unadjustable, default: false\r\n    // this._rowHidden = [false]; // element true make the row edge unadjustable, default: false\r\n\r\n    this._colMinWidths = [1]; // element sets minimum column width in pixels\r\n    this._colMaxWidths = [Infinity]; // element sets maximum column width in pixels\r\n    this._rowMinHeights = [1]; // element sets minimum row height in pixels\r\n    this._rowMaxHeights = [Infinity]; // element sets maximum row height in pixels\r\n\r\n    this._eGrid = eGrid;\r\n    this._colLineNames = [];\r\n    this._colWidths = [];\r\n    this._colLinePositions = [];\r\n    this._rowLineNames = [];\r\n    this._rowHeights = [];\r\n    this._rowLinePositions = [];\r\n    this._gridCells = [];\r\n    this._state = 0; // 0:idle|1:adjust\r\n    this._currentCell;\r\n    this._activeColLine = -1;\r\n    this._activeRowLine = -1;\r\n    this._offsetX0;\r\n    this._offsetY0;\r\n\r\n    if (\r\n      [\"grid\", \"inline-grid\"].every(\r\n        value => value !== window.getComputedStyle(this._eGrid).display\r\n      )\r\n    )\r\n      throw \"Container is not a grid\";\r\n\r\n    this._analyze(); // get grid lines and layout of its items\r\n    this._configure(); // set callbacks on its items\r\n\r\n    // create object-bound callback functions\r\n    this._mouseover = this.onMouseOverBorder.bind(this);\r\n    this._mouseout = this.onMouseOutBorder.bind(this);\r\n    this._mousedown = this.onMouseDownBorder.bind(this);\r\n    this._onmousemove = this.onMouseMove.bind(this);\r\n    this._onmouseup = this.onMouseUp.bind(this);\r\n  }\r\n\r\n  enable() {\r\n    if (this._enabled) return; // nothing to do\r\n    this._enabled = true;\r\n    this._gridCells.forEach(cell => {\r\n      // add mouse event listeners\r\n      cell.eBorder.addEventListener(\"mouseover\", this._mouseover);\r\n      cell.eBorder.addEventListener(\"mouseout\", this._mouseout);\r\n      cell.eBorder.addEventListener(\"mousedown\", this._mousedown);\r\n    });\r\n  }\r\n  disable() {\r\n    if (!this._enabled) return; // nothing to do\r\n    this._enabled = false;\r\n    this._gridCells.forEach(cell => {\r\n      // add mouse event listeners\r\n      cell.eBorder.removeEventListener(\"mouseover\", this._mouseover);\r\n      cell.eBorder.removeEventListener(\"mouseout\", this._mouseout);\r\n      cell.eBorder.removeEventListener(\"mousedown\", this._mousedown);\r\n    });\r\n  }\r\n  // hide() {}\r\n  // show() {}\r\n  // reconfigure() {}\r\n  // restore() {}\r\n  // save() {}\r\n  // load() {}\r\n\r\n  /**\r\n   * Analyzes the grid container's attributes and populates the following \"private\" properties:\r\n      _colLineNames\r\n      _colWidths\r\n      _colLinePositions\r\n      _rowLineNames\r\n      _rowHeights\r\n      _rowLinePositions\r\n      _gridCells\r\n   */\r\n  _analyze() {\r\n    // \"##px\" -> ## converter\r\n    const cssPxSize = str => Number(str.match(/\\d+(?=px)/));\r\n\r\n    // identify the (relative) position of the grid lines\r\n    const parseTemplateDefs = (cssParams, offset) => {\r\n      let wasSize = cssParams.template[0] != \"[\";\r\n      let sizes = [],\r\n        names = wasSize ? [[]] : [];\r\n      cssParams.template.match(/(\\[[^\\]]+\\])|([\\d\\.]+)/g).forEach(token => {\r\n        if (token[0] == \"[\") {\r\n          // edge names\r\n          // names.push(token.slice(1, -1).match(/[^ ]+/g));\r\n          names.push(token);\r\n          wasSize = false;\r\n        } else {\r\n          sizes.push(Number(token));\r\n          if (wasSize) names.push(\"\"); //names.push([]); // no name given\r\n          wasSize = true;\r\n        }\r\n      });\r\n\r\n      // calculate the line positions\r\n      let edges = sizes.reduce((r, a, i) => (r.push(r[i] + a), r), [\r\n        offset + cssPxSize(cssParams.border) + cssPxSize(cssParams.padding)\r\n      ]);\r\n      if (cssParams.gap && cssParams.gap != \"normal\") {\r\n        let gap = cssPxSize(cssParams.gap);\r\n        edges = edges.map(pos => pos + i * gap);\r\n      }\r\n\r\n      // template, gap, border, padding\r\n      return {\r\n        names: names,\r\n        sizes: sizes,\r\n        edges: edges\r\n      };\r\n    };\r\n\r\n    // getBoundingClientRect() returns the position of outside edges of borders\r\n    let gridPos = (({ top, left }) => ({ top, left }))(\r\n      this._eGrid.getBoundingClientRect()\r\n    );\r\n\r\n    // analyze the column configurations\r\n    ({\r\n      names: this._colLineNames,\r\n      sizes: this._colWidths,\r\n      edges: this._colLinePositions\r\n    } = parseTemplateDefs(\r\n      (({ gridTemplateColumns, columnGap, borderLeftWidth, paddingLeft }) => ({\r\n        template: gridTemplateColumns,\r\n        gap: columnGap,\r\n        border: borderLeftWidth,\r\n        padding: paddingLeft\r\n      }))(window.getComputedStyle(this._eGrid)),\r\n      gridPos.left\r\n    ));\r\n\r\n    // analyze the row configurations\r\n    ({\r\n      names: this._rowLineNames,\r\n      sizes: this._rowHeights,\r\n      edges: this._rowLinePositions\r\n    } = parseTemplateDefs(\r\n      (({ gridTemplateRows, rowGap, borderTopWidth, paddingTop }) => ({\r\n        template: gridTemplateRows,\r\n        gap: rowGap,\r\n        border: borderTopWidth,\r\n        padding: paddingTop\r\n      }))(window.getComputedStyle(this._eGrid)),\r\n      gridPos.top\r\n    ));\r\n\r\n    // collect grid cells' CSS's\r\n    this._gridCells = [...this._eGrid.children].reduce((r, cell, i) => {\r\n      let css = window.getComputedStyle(cell);\r\n      let cellRect = cell.getBoundingClientRect();\r\n      const findLine = (px, lines) => {\r\n        return lines\r\n          .map(line => Math.abs(line - px))\r\n          .reduce((iMin, x, i, arr) => (x < arr[iMin] ? i : iMin), 0);\r\n      };\r\n      return (\r\n        r.push({\r\n          eBorder: cell,\r\n          eCellCSS: css,\r\n          left: findLine(\r\n            cellRect.left - cssPxSize(css.marginLeft),\r\n            this._colLinePositions\r\n          ),\r\n          right: findLine(\r\n            cellRect.left + cellRect.width + cssPxSize(css.marginRight),\r\n            this._colLinePositions\r\n          ),\r\n          top: findLine(\r\n            cellRect.top - cssPxSize(css.marginTop),\r\n            this._rowLinePositions\r\n          ),\r\n          bottom: findLine(\r\n            cellRect.top + cellRect.height + cssPxSize(css.marginBottom),\r\n            this._rowLinePositions\r\n          )\r\n        }),\r\n        r\r\n      );\r\n    }, []);\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  _configure() {\r\n    this._eGrid.classList.add(\"grid-works\", \"wrapper\");\r\n    this._gridCells.forEach(cell => {\r\n      // insert a borderless div between the grid cell and its content\r\n      let cssBorder = window.getComputedStyle(cell.eBorder);\r\n      let innerHTML = cell.eBorder.innerHTML;\r\n\r\n      //\r\n      let eContent = document.createElement(\"div\");\r\n      eContent.className = \"grid-works content\";\r\n      eContent.classList.add(...cell.eBorder.classList);\r\n      eContent.innerHTML = innerHTML;\r\n\r\n      eContent.style =\r\n        \"height: 100%; width: 100%; margin: 0; border: none; padding: 0\";\r\n      eContent.style.paddingLeft = cssBorder.paddingLeft;\r\n      eContent.style.paddingTop = cssBorder.paddingTop;\r\n      eContent.style.paddingRight = cssBorder.paddingRight;\r\n      eContent.style.paddingBottom = cssBorder.paddingBottom;\r\n      cell.eContent = eContent;\r\n\r\n      cell.eBorder.classList.add(\"grid-works\", \"border\");\r\n      cell.eBorder.innerHTML = \"\";\r\n      cell.eBorder.appendChild(eContent);\r\n      cell.eBorder.style.padding = \"0\";\r\n\r\n      cell.eContent.addEventListener(\"mouseover\", e => {\r\n        // stop eContent's mouseover to bubble to eBorder\r\n        e.stopPropagation();\r\n      });\r\n      cell.eContent.addEventListener(\"mouseout\", e => {\r\n        // stop eContent's mouseout to bubble to eBorder\r\n        e.stopPropagation();\r\n      });\r\n    });\r\n\r\n    // set configurations\r\n    // this.colHidden = this._colHidden;\r\n    // this.rowHidden = this._rowHidden;\r\n    this.colLineFixed = this._colLineFixed;\r\n    this.rowLineFixed = this._rowLineFixed;\r\n    this.colMinWidths = this._colMinWidths;\r\n    this.colMaxWidths = this._colMaxWidths;\r\n    this.rowMinHeights = this._rowMinHeights;\r\n    this.rowMaxHeights = this._rowMaxHeights;\r\n  }\r\n\r\n  _is_adjustable(line, edge, fixed_edges) {\r\n    console.log(!(fixed_edges[line] || line == edge));\r\n    return !(fixed_edges[line] || line == edge);\r\n  }\r\n\r\n  _on_border(e) {\r\n    // initialize return object\r\n    let rval = { left: false, right: false, top: false, bottom: false };\r\n\r\n    // get current cell, exit if not on border\r\n    this._currentCell = this._gridCells.find(cell => e.target == cell.eBorder);\r\n    if (!this._currentCell) return rval;\r\n\r\n    // detect if mouse is on which border\r\n    let left_offset = e.clientX - e.target.offsetLeft;\r\n    let right_offset =\r\n      e.target.offsetLeft + e.target.offsetWidth - e.clientX - 1;\r\n    let top_offset = e.clientY - e.target.offsetTop;\r\n    let bottom_offset =\r\n      e.target.offsetTop + e.target.offsetHeight - e.clientY - 1;\r\n\r\n    let left_thickness = getComputedStyle(e.target).borderLeftWidth.slice(\r\n      0,\r\n      -2\r\n    );\r\n    let right_thickness = getComputedStyle(e.target).borderRightWidth.slice(\r\n      0,\r\n      -2\r\n    );\r\n    let top_thickness = getComputedStyle(e.target).borderTopWidth.slice(0, -2);\r\n    let bottom_thickness = getComputedStyle(e.target).borderBottomWidth.slice(\r\n      0,\r\n      -2\r\n    );\r\n\r\n    // then check if the lines are adjustable\r\n    if (left_offset <= left_thickness) {\r\n      rval.left = this._is_adjustable(\r\n        this._currentCell.left,\r\n        0,\r\n        this._colLineFixed\r\n      );\r\n    } else if (right_offset <= right_thickness) {\r\n      rval.right = this._is_adjustable(\r\n        this._currentCell.right,\r\n        this._colLinePositions.length - 1,\r\n        this._colLineFixed\r\n      );\r\n    }\r\n\r\n    if (top_offset <= top_thickness) {\r\n      rval.top = this._is_adjustable(\r\n        this._currentCell.top,\r\n        0,\r\n        this._rowLineFixed\r\n      );\r\n    } else if (bottom_offset <= bottom_thickness) {\r\n      rval.bottom = this._is_adjustable(\r\n        this._currentCell.bottom,\r\n        this._rowLinePositions.length - 1,\r\n        this._rowLineFixed\r\n      );\r\n    }\r\n    return rval;\r\n  }\r\n\r\n  onMouseOverBorder(e) {\r\n    if (this._state > 0) return;\r\n\r\n    // detect what could be adjusted: col/row/both\r\n    let on = this._on_border(e);\r\n\r\n    // set eBorder class\r\n    if (on.left || on.right) e.target.classList.add(\"col\");\r\n    if (on.top || on.bottom) e.target.classList.add(\"row\");\r\n  }\r\n\r\n  onMouseMoveBorder(e) {\r\n    if (this._state > 0) return;\r\n\r\n    // detect what could be adjusted: col/row/both\r\n    let on = this._on_border(e);\r\n\r\n    // update eBorder class\r\n    if (on.left || on.right) e.target.classList.add(\"col\");\r\n    else e.target.classList.remove(\"col\");\r\n    if (on.top || on.bottom) e.target.classList.add(\"row\");\r\n    else e.target.classList.remove(\"row\");\r\n  }\r\n\r\n  onMouseOutBorder(e) {\r\n    if (this._state > 0) return;\r\n\r\n    // turn off cursor only if not active\r\n    if (!this._state) e.target.classList.remove(\"col\", \"row\");\r\n  }\r\n\r\n  onMouseDownBorder(e) {\r\n    // id which border(s) is hit\r\n    let on = this._on_border(e);\r\n    if (on.left) this._activeColLine = this._currentCell.left;\r\n    else if (on.right) this._activeColLine = this._currentCell.right;\r\n    if (on.top) this._activeRowLine = this._currentCell.top;\r\n    else if (on.bottom) this._activeRowLine = this._currentCell.bottom;\r\n\r\n    // check for \"erroneous\" callback\r\n    if (this._activeColLine < 0 && this._activeRowLine < 0) return 0;\r\n\r\n    // turn on grid-adjuster\r\n    this._state = 1;\r\n\r\n    // store the current mouse pointer location\r\n    if (this._activeColLine >= 0)\r\n      this._offsetX0 = this._colLinePositions[this._activeColLine] - e.pageX;\r\n    if (this._activeRowLine >= 0)\r\n      this._offsetY0 = this._rowLinePositions[this._activeRowLine] - e.pageY;\r\n\r\n    // add window mousemove callback\r\n    window.addEventListener(\"mousemove\", this._onmousemove);\r\n    window.addEventListener(\"mouseup\", this._onmouseup);\r\n  }\r\n\r\n  onMouseUp(e) {\r\n    // remove the mousemove callback\r\n    window.removeEventListener(\"mousemove\", this._onmousemove);\r\n    window.removeEventListener(\"mouseup\", this._onmouseup);\r\n\r\n    // turn off grid-adjuster\r\n    this._state = 0;\r\n\r\n    // clear active line indicators\r\n    this._activeColLine = -1;\r\n    this._activeRowLine = -1;\r\n  }\r\n\r\n  _update_template(line, newpos, cssName, names, sizes, edges, mins, maxs) {\r\n    // get the change\r\n    let delta = newpos - edges[line];\r\n    let newSize0 = sizes[line - 1] + delta;\r\n    let newSize1 = sizes[line] - delta;\r\n    if (newSize0 < mins[line - 1]) {\r\n      newSize1 = newSize0 + newSize1 - mins[line - 1];\r\n      newSize0 = mins[line - 1];\r\n    } else if (newSize1 < mins[line]) {\r\n      newSize0 = newSize1 + newSize0 - mins[line];\r\n      newSize1 = mins[line];\r\n    } else if (newSize0 > maxs[line - 1]) {\r\n      newSize1 = newSize0 + newSize1 - maxs[line - 1];\r\n      newSize0 = maxs[line - 1];\r\n    } else if (newSize1 > maxs[line]) {\r\n      newSize0 = newSize1 + newSize0 - maxs[line];\r\n      newSize1 = maxs[line];\r\n    }\r\n\r\n    // update the edge position and sizes of adjacent cells\r\n    edges[line] = edges[line - 1] + newSize0;\r\n    sizes[line - 1] = newSize0;\r\n    sizes[line] = newSize1;\r\n\r\n    // update the template\r\n    this._eGrid.style[cssName] = sizes.reduce((cssstr, size, i) => {\r\n      cssstr += size + \"px\" + names[i + 1];\r\n      return cssstr;\r\n    }, names[0]);\r\n\r\n    // return updated edges & sizes\r\n    return {\r\n      sizes: sizes,\r\n      edges: edges\r\n    };\r\n  }\r\n\r\n  onMouseMove(e) {\r\n    e.preventDefault();\r\n    if (this._activeColLine >= 0)\r\n      ({\r\n        sizes: this._colWidths,\r\n        edges: this._colLinePositions\r\n      } = this._update_template(\r\n        this._activeColLine,\r\n        this._offsetX0 + e.pageX,\r\n        \"gridTemplateColumns\",\r\n        this._colLineNames,\r\n        this._colWidths,\r\n        this._colLinePositions,\r\n        this._colMinWidths,\r\n        this._colMaxWidths\r\n      ));\r\n\r\n    if (this._activeRowLine >= 0)\r\n      ({\r\n        sizes: this._rowHeights,\r\n        edges: this._rowLinePositions\r\n      } = this._update_template(\r\n        this._activeRowLine,\r\n        this._offsetY0 + e.pageY,\r\n        \"gridTemplateRows\",\r\n        this._rowLineNames,\r\n        this._rowHeights,\r\n        this._rowLinePositions,\r\n        this._rowMinHeights,\r\n        this._rowMaxHeights\r\n      ));\r\n  }\r\n\r\n  setOptions(opts) {\r\n    if (opts._colLineFixed) {\r\n      // options\r\n      this._colLineFixed = []; // element true to make the column edge unadjustable, default: false\r\n    }\r\n    this._colMinWidths = []; // element sets minimum column width in pixels\r\n    this._colMaxWidths = []; // element sets maximum column width in pixels\r\n    this._rowLineFixed = []; // element true make the row edge unadjustable, default: false\r\n    this._rowMinHeights = []; // element sets minimum row height in pixels\r\n    this._rowMaxHeights = []; // element sets maximum row height in pixels\r\n  }\r\n}\r\n\r\n// make gridWorks available to all Objects\r\nObject.defineProperty(Element.prototype, \"gridWorks\", {\r\n  get: function() {\r\n    Object.defineProperty(this, \"gridWorks\", {\r\n      value: new gridWorks(this, [...arguments])\r\n    });\r\n\r\n    return this.gridWorks;\r\n  },\r\n  configurable: true,\r\n  writeable: false\r\n});\r\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });